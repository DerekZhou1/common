ClassA,ClassB :用于做测试
ClassInitial：用于展示一个对象在实例化的过程中代码的执行顺序：静态代码块>非静态代码块（构造代码块）>构造方法

OuterClass: 内部类实例，测试多种内部类，静态内部类，成员内部类，局部(方法)内部类，匿名内部类

1.Factory : 简单工厂模式
//简单工厂模式：工厂就是生产的意思，简单工厂模式就是专门定义个类，这个类用来实例化其他类，
//根据条件的不同实例化不同的类

2 strategyMode:策略模式 策略模式定义了算法家族，分别封装起来，让他们之间相互替换，此模式让算法的变化，
不会影响到使用算法的客户

3DecoratotMode:装饰模式就是在不改变原来的类文件和使用继承的情况下，动态的扩展一个功能，
通过创建一个包装对象，来包裹真实的类

4FactoryMethod 工厂方法模式是简单工厂模式的进一步抽象，更具有一般性，每一个工厂只对应一个具体类，更加符合开放-封闭原则
因为增加新的特性时不用修改工厂，只增加工厂
缺点是增加了代码和复杂程度

5 Prototype：原型模式：原型模式是从一个对象再创建另外一个可定制的对象，而不需要知道创建的细节.
就是克隆

6 ModelMode模板方法模式：模板方法主要在一个方法中大部分的功能一致，但在少数细节方面有不同，就抽象出一个模板类，
将需要做的功能的主要逻辑和结构组成放在抽象类的方法中，不同的地方通过用不同的子类继承，然后重写细节来完成
核心：模板模式是将重复的代码提升到超类,去除子类中的重复代码。

7Facade ：外观模式

8 BuilderMode 建造者模式： 将一个复杂的对象的构建与它的表示分离，使同样的构建过程有不同的表示
（适用于那些构建过程稳定的对象,对象算法独立于他们的组成方式）

9 ObserverMode 观察者模式（发布-订阅模式） 定义了一种一对多的依赖关系，让多个观察者对象
同时监听某一个主题对象，这个主题对象在状态发生变化时，会通知所有观察者对象，使他们能够更新自己
观察者模式适用于当一个对象改变时，会有其他多个对象发生改变的状况
核心：抽象主题类仍然依赖于抽象观察者，并没有完全的解耦，可以使用委托来完成完全解耦
.net委托实现很简单  zl.update+=new EventHandler(delegatefunc);
可以将委托看做一种类型，EventHandler是函数的抽象，上面的代码相当于将委托类进行实例化然后绑定到zl的update方法
当执行update时，delegatefunc会执行


10delegateMode： 委托模式 实现触发事件和监听事件的完全解耦。java的委托要利用反射

11 Reflect:反射机制演示

12 AbstractFactoryMode 抽象工厂模式，用于对一整个系列进行切换，每个系列的结构是稳定的
但是具体的实现不一样

13 StateMode 用于当一个对象的状态转换的表达式过于复杂时（比如很多ifelse），把
对象的判断逻辑移到表示一系列不同状态的类当中

14 AdapterMode  对象适配器模式 ，对于短期无法修改接口，对接口进行一次封装，满足现在运行的需求
是一种妥协的办法，不建议使用

15MementoMode 备忘录模式，在不破坏封装的情况下对一个对象进行状态拷贝，用于以后恢复

16 CompositeMode 组合模式，当需求中体现部分与整体的结构时，希望用户忽略单个对象和对象整体的时候
使用组合模式，将整体的所有方法组合起来，在部分中也同样可以适用

17 IteratorMode 迭代器模式，用于对一个集合进行遍历

18 Association 关联举例，在uml结构图中，横向关系可细化为关联，组合，聚合，依赖等。各项举例

19 SingletonMode 单例模式，保证类只有一个实例，并提供一个能够访问它的全局访问点

20 MultiThread 多线程举例

21 ResourceSynchronize 多线程对共享资源的访问，线程同步的方式  synchronized 与lock的区别

22 PrintABC 使用三线程打印ABC,要求打印为“ABCABC..”循环十遍 
非常经典的多线程例子，通过断点调试，可以充分学习多线程对临界资源的争抢行为。

23 LockExample 锁的演示，可重入锁（递归锁）和不可重入锁（自旋锁）的实现原理

24 VisitorPattern 访问者模式 用于将数据结构和数据结构的操作分离开来

25 PorxyPattern 代理模式，为其他对象提供一种代理以控制对这个对象的访问

25 FlyWeightPattern 享元模式 对于一个类的大量的相似的对象实例，使用享元模式共享代码，
减少对象数量，提升性能

26 CommandPattern 命令模式，将一个操作封装为一个对象，从而可以对不同的请求对客户进行参数化。
对请求排队或记录请求日志，以及支持撤销
核心：命令模式的目的是保存请求（操作）的记录和顺序

27 ResponsePattern 职责链模式，请求者并不知道自己的请求由哪一个决策者来操作，实现请求和决策的分离